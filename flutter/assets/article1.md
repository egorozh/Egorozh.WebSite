# Первый взгляд на переход с Xamarin Native на Flutter

## Введение

Привет! В этой статье я хочу поделиться своим опытом перехода с одной технологии на другую.
Рассказать о том, как был приверженцем одной технологии, всячески топил за неё и защищал в барных
посиделках с друзьями. И как после вынужденного перехода на другую - теперь ни под каким предлогом
не готов к ней возвращаться.

Это история о переходе с Xamarin Native на Flutter. В ней я постараюсь сравнить оба фреймворка с
точки зрения личного опыта. Также в качестве лирического отступления в конце статьи порассуждаю о
своём идеальном мобильном фреймворке мечты.

Эта статья, на мой взгляд, будет интересна для разработчиков без опыта работы с декларативными
фреймворками. Которые (как и я до недавнего времени) все ещё используют .xml и .xib файлы для
написания интерфейса. Расскажу о своих старых заблуждениях касательно декларативных фреймворков,
которые развенчал опыт работы с Flutter.

Коротко о себе: меня зовут Егор и я занимаюсь разработкой мобильных приложений более двух лет. Два
года участвовал в разработке большого приложения, используя Xamarin Native. Приложение закончило
своё существование по причине, не связанной с этой технологией. Недавно переключился на новый
проект, который мы начали делать, используя Flutter.
Небольшой дисклеймер: употребляя ниже термин "декларативный UI" я имею ввиду исключительно подходы
Compose, Flutter и SwiftUI к построению интерфейса.

## О разработке на Xamarin Native

Разработка проекта, с которого мы вынуждены были перейти на Flutter велась примерно с 2017-2018
года. Я же присоединился в 2022 с нулевым опытом разработки под мобильные платформы (на тот момент
был опыт исключительно разработки под Desktop на WPF и AvaloniaUI). Проект представлял собой
социальную сеть для соседей с чатами, сообществами, лентой, умным домом и прочими сервисами. Кол-во
экранов превышало добрую сотню.
За основу был взят фреймворк MvvmCross, который по сути единственный на рынке, позволяющий
использовать разделяемый UI под каждую из платформ. Под android UI верстался с помощью xml и C#
кода. Под ios соответственно использовались xib файлы и так же C#. Команда была поделена на две
части, каждая занималась версткой под конкретную платформу и написание общего кода. Были и товарищи
успешно реализующие интерфейс под обе платформы.

Пример кода биндингов в MvvmCross для View на iOS (исходный код)

За все время работы на проектом, я всячески болел за эту технологию. Она позволяла использовать все
плюшки нативного UI, при этом мы писали на любимом языке и переиспользовали огромное кол-во кода.
Скорость разработки тоже не уступала нативной разработке. Мы использовали те же классы и модели, что
и в нативной разработке - Activity, RecyclerView, UIController, UICollectionView и т.п. Возникает
проблема, ищешь решение на Java (Kotlin) или Swift и переносишь его практически один к одному на C#.
Если решение - нативная библиотека, делаешь к ней обертку за час-полтора и используешь (с некоторыми
иногда было не так всё просто). Правда использовать тот же Jetpack Compose (или SwiftUI) мы не
могли.

За год до закрытия была поставлена задача сделать глобальный редизайн приложения. Именно эта фича
прокачала меня в разработке особенно сильно. Были разработаны новые библиотеки с контролами под
android и iOS. Были переосмыслены многие старые экраны, зачастую приходилось многое переделывать из
написанного ранее. При этом все контролы мы реализовывали с нуля на C# - будь то какая-то карточка,
кнопка, радио кнопка или хедер, который забеляется при подскролливании контента под него.
После выхода .net 7 мы перешли с Xamarin на него. Во-первых, новая версия MVVM Cross перестала
поддерживать классический Xamarin. Во-вторых, хотелось идти в ногу со временем, использовать
последнюю версию языка и повысить перформанс чисто за счет перехода. За месяц до закрытия проекта мы
перешли на .net 8, размышляли о включении NativeAot на iOS, чтобы приложение открывалось совсем
молниеносно. Хотя и без NativeAot, iOS приложение намного шустрее запускалось, относительно
android'a.

После закрытия проекта, я думал, что буду дальше топить за этот подход, позволяющий писать
приложения с нативным UI на одном языке. Были мысли написать свой аналог MvvmCross'a, с обширным
включением Source Generator'ов для генерации кода и отказа от рефлексии везде, где это возможно (DI,
serialization и т.п. - не забываем про NativeAot, с которым стандартный сериализатор не работает).

Если подвести итоги по главе с Xamarin'ом, можно выделить следующие пункты, которые мне нравились в
сравнении с классической нативной разработкой:

- обширная общая кодовая база - вся бизнес-логика, работа с БД, с сетью.
  один язык для разработки на обеих платформах. Причем C# мне нравится сильно больше, чем тот же
  Swift. И в этом плане, если брать разработку исключительно под iOS, я бы рассмотрел вариант
  использовать .NET-iOS, если у вас есть подобные предубеждения к Swift'у.
- удобный туллинг - но только в плане работы с кодом, обширные рефакторинги C# кода, удобный
  менеджер
  пакетов, удобные .csproj файлы для настроек проекта. Редактировать же UI файлы для android'a было
  не
  супер удобно (об этом в минусах).
- привычный набор библиотек из nuget, с которыми работает любой .net-разработчик.
- обширное кол-во возможностей для оптимизаций перформанса, которое предоставляет платформа .NET -
  Span'ы, Struct'ы и прочие вещи, которые, на мой взгляд, позволяют делать более производительный
  код
  даже в сравнении с нативом.
- похожие абстракции при работе с MVVM для разработчиков, имеющих опыт с другими UI фреймворками на
  C#. Подход к ViewModel с INotifyPropertyChanged точно такой же как в них, если брать MvvmCross в
  качестве основы.

Из того, что не нравилось:

- не удобный тулинг при верстке UI. Автодополнение в .xml в Rider'e работало странно. Показ
  атрибутов
  работал только для основных контролов. Для наших контролов подсказок не было. Однако, в Visual
  Studio это работало.
- при разработке случались коллизии при реализации фичи на одной платформе - общий код в виде
  моделей
  и ViewModel'ей не мапился на UI второй без дополнительных костылей или переделывания общего кода.
  отсутствие поддержки писать декларативный UI. Аналога Compose и SwiftUI нет в Xamarin Native.
  есть проблемы с дженериками на Android'e. Поэтому на проекте было правило не использовать их для
  Activity, View и Fregment'ов.
- были проблемы с некоторыми библиотеками, которые работали на старом Xamarin, но после перехода на
  .NET 7 перестали работать. Потребовалось время, когда появились форки библиотек с поддержкой .NET
  7.
  проблемы с MvvmCross. У него был ряд проблем, которые до сих не исправлены. Плюс он предоставляет
  свой DI, который не заменить на свою реализацию каким-то простым способом. Отсюда проблемы с
  долгим
  стартом приложения - эту проблему частично сглаживало включение AoT компиляции.
- нет hot-reload'a (в отличие от того же MAUI) и адекватного previewer'a. В итоге единственный
  способ
  проверить, что получилось после правок разметки - запускать эмулятор и навигироваться на нужный
  экран.
- нет profiler'a памяти, чтобы искать утечки именно в .NET части приложения.

Как видите, недостатков вышло немало, однако в тот момент я не обращал на них внимание и
действительно верил в технологию, так как из альтернатив пробовал только классический натив для iOS.

Кстати говоря, в этот момент я воспринимал декларативный подход к UI просто как вынос создания
контролов из файлов разметки в код. Я думал, и в чем весь хайп? Вот я на C# делаю тоже самое -
создаю LinearLayout'ы с TextView и прочими View в виде функций, чем вам не Jetpack Compose. Плюс
добавлял еще абстракций для более удобного их создания в коде. А потом в итоге так же делал биндинги
к созданным контролам, которые висели в памяти в течение всего жизненного цикла экрана. Если вдруг
вы размышляете о декларативном UI так же, знайте, Compose, Flutter и SwiftUI не работают так, что мы
создаем при старте экрана один набор виджетов и потом мутируем их состояние путем изменения их
свойств, когда на экране что-то меняется, как это делается в случае классического натива. Тут
совершенно другая идеология, плюсы которой для меня теперь абсолютно очевидны.

```csharp
public static View CreateView(Context context)
{
   return new LayoutWrapper<RelativeLayout>(RootView(context))
   {
       new LayoutWrapper<TouchEventLinearLayout>(ContentContainer(context))
       {
           StickerView(context),
           new LayoutWrapper<LinearLayout>(FooterContainer(context))
           {
               new LayoutWrapper<FrameLayout>(StatusContainer(context))
               {
                   ProgressIndicator(context),
                   ErrorImageView(context)
               },
               new LayoutWrapper<FrameLayout>(DateContainer(context))
               {
                   DateTextView(context)
               },
           }
       },
   };
}

```

Пример создания контролов из C# кода, вместо XML

В конечном итоге, проект заморозили по бизнесовым причинам, которые не интересны в рамках текущего
рассказа. Команда из 14 человек распалась - из них половина ушла в бэкенд-разработку, а я
подключился к проекту, который решено было делать на Flutter'e, опыта с которым не было ни у кого из
команды.

## Начало разработки на Flutter

Хочется отметить, чтобы не вводить в заблуждение в дальнейшем, предыдущий проект и текущий
совершенно не сопоставимы по объему и сложности. Предыдущий проект был настоящей социальной сетью с
дополнительными сервисами, связанными с домом и соседями. Там был дизайн со своей философией,
дизайнеры ежедневно взаимодействовали с командой в обе стороны, что накладывало на разработчика
дополнительные сложности, связанные с тем, чтобы добиваться "pixel-perfect'а" с макетами в фигме.
Новый же проект - типичный сервис для заказа услуг, с возможностью сделать заказ, посмотреть текущие
и активные заказы, профиль, и какие-то минималистичные экраны деталок новостей и т.п.

Разработка началась с того, что мы выбирали архитектуру приложения, которой будем придерживаться, и
определением джентльменского набора из библиотек, которые собираемся использовать. По итогу, после
ресерча популярных стейт-менеджеров для Flutter был выбран bloc, как наиболее понятный для нас - C#
перебежчиков. Для навигации выбрали auto-router. Для логирования выбрали Talker, который я
подсмотрел в уроках его автора, когда смотрел видеоуроки по Flutter. Для DI - injectable и retrofit
для генерации api клиентов.

Касательно архитектуры была выбрана clean архитектура с feature-first структурой приложения. Каждый
блок приложения (экран, раздел) представляет собой отдельную feature со своими слоями data, domain и
presentation. Есть специальный плагин для android-студии, который по названию фичи сразу создает
иерархию из папок. Сильно тут распинаться не буду про clean-architecture. Хочется отметить только,
насколько это облегчило жизнь при разработке. Особенно после многолетнего опыта работы с layer-first
подходом к структуре. Когда у нас на главном уровне есть папки Views, ViewModels, Models, Engines,
Services, Primitives и т.д. и потом при разработке одного экрана или маленькой его части приходилось
мотаться по всему проекту в поисках необходимых файлов и классов, в которых нужно было найти ту или
иную логику. Понятно, что никто нас не ограничивал тогда заложить ту же feature first структуру. Но
этот подход редко встречается на уровне примеров в ui фреймворках на C#. Даже при создании пустого
проекта в той же AvaloniaUI папки проекта выстроены именно в layer-first стиле. Именно опыт с
флаттером убедил меня в необходимости придерживаться clean architecture с подобной структурой и в C#
проектах.

Теперь и для проектов на Avalonia использую clean architecture + feature first структуру
Итак, вот мы начали верстать первые экраны, осваивать bloc, dart и flutter в целом, и что сразу же
хочется отметить - это высокую скорость разработки. Экраны верстаются МГНОВЕННО в сравнении с
нативом. И при этом один раз, сразу под обе платформы. Буквально, верстку для получения красивого
экрана в соответствии с макетом из фигмы я делаю минут за 30. На xml подобная работа заняла бы у
меня час-полтора в лучшем случае. На iOS из опыта коллег выходит еще дольше - у меня ввиду
небольшого опыта - это всегда X2 к времени относительно android'а. Затем к готовой верстке
прикрепляется bloc, прокидываются события, закладывается state. В блоке всю логику выносим в
UseCases из слоя Domain'a. И наш слой presentation готов. В предыдущем проекте на Xamarin никаких
UseCase'ов не было. Вся бизнес логика выполнялась в ViewModel'aх и Engine'aх, которые
инкапсулировали в себе работу с бэкендом, что сейчас воспринимается чем-то неправильным, без четкого
разделения на слои.

В Flutter есть невероятно крутой hot-reload. Любое изменение мгновенно применяется на экране
эмулятора при верстке. Это же касается и изменений обычных методов в ваших блоках, use-case'ах или
репозиториях. Это ускоряет разработку в разы в сравнении с Xamarin'ом. В MAUI правда завезли
хот-релоад, но, как мне кажется, это его не спасет от забвения, которое неминуемо, на мой взгляд.
Второе, декларативный UI - это реально круто. Мы используем bloc и clean архитектуру в Flutter
проекте и код получается максимально простой для понимания. Сразу вспоминаются какие-нибудь стабы и
заглушки, которые должны были отрисовываться в нативе в случае ошибок или пустого списка. В итоге
View покрывалась тонной биндингов на привязку к Visibility тех или иных контролов на экране.
Поддерживать такое было непросто, постоянно вылезали баги, связанные с некорректным отображением
чего-либо для какой-то определенной ситуации. После работы с флаттером и концепцией различных
State'ов под разные состояния экрана, вспоминаешь про все это как страшный сон.

```csharp
_contentChangesTrigger = new CollectionInitializedTrigger<IEnumerable<Member>>(
   state =>
   {
       switch (state)
       {
           case ContentState.Filled:
               SearchView.Reveal();
               ContentView.Reveal();
               EmptySearchLabel.Hide();
               NoContentView.Hide();
               break;


           case ContentState.Empty:
           case ContentState.FailedToBeFilled:
               AdjustStub();
               bool filterAssigned = !string.IsNullOrEmpty(SearchView.Text);
               SearchView.Hidden = !filterAssigned;
               ContentView.Hide();
               EmptySearchLabel.Hidden = !filterAssigned;
               NoContentView.Hidden = filterAssigned;
               break;
       }
   })
   .LinkTo(Disposer);

```

Типичный код по скрытию-показу контролов из проекта на Xamarin Native.

В третьих, хочется поговорить о Dart. Начну с того, что меня до сих пор в нём смущает по сей день, в
разрезе перехода с C#. Очень не нравится система импортов. Раздражает наличие в каждой папке
одноимённого файла с экспортом всех остальных файлов в папке, которые должен генерировать плагин, но
который не работает в последних версиях студии. Не нравится, что при рефакторинге переименования
класса, не переименовывается название файла. Так же нет рефакторинга - подключения всех импортов в
файле с кодом (отсутствие такого же рефакторинга в случае kotlin в продуктах JetBrains кстати тоже
для меня стало неприятным открытием. Прокликивать каждое место в коде, который копируешь откуда-то,
чтобы подтянуть необходимые import'ы не очень приятно после работы в Rider'e c C#, где это делается
в одно нажатие).

Также в Dart кодогенерация работает через build runner, что совсем пока не сравнится с теми же
Incremental Source Generators в C#, когда код генерируется мгновенно при написании конкретных
атрибутов, от которых зависит где и каким образом будет генерироваться код. Из того, к чему я сразу
привык - это отсутствие оператора "new" перед созданием объектов. Теперь, при возвращении в C#
постоянно забываю писать его перед названием класса. Еще понравилось наличие sealed классов,
позволяющих не использовать дефолтное значение при паттерн-матчинге. Такое же поведение и у здешних
enum'ов. В итоге при расширении типа новым значением мы будем ловить ошибку в сompile time везде,
где использовали pattern-matching.

В четвертых, не понятен прикол с одним файлом локализации на весь проект во Flutter'e. Видел issue
на это, пока официального решения для возможности разделения файла на несколько частей (например, на
каждую фичу) от команды флаттера нет. Держать один файл с локализованными строками совсем неудобно
даже для небольшого проекта.

В целом, впечатление о Flutter исключительно позитивное в контексте удобства и в сравнении с
Xamarin. Однако, смущает dart и его ограничения, в плане многопоточности и прочих нюансов, описанных
выше. Так же смущает обширное число issues, на которые до сих пор натыкаешься при разработке. Их в
репозитории флаттера сейчас 12к, за три месяца работы и мной было добавлено несколько штук. Основной
плюс флаттера для меня - удобная система виджетов, позволяющая реализовывать экраны с какой-то
невероятной скоростью. Так же flutter показал для меня, что декларативный UI неизбежное будущее, а
не дань моде. И если брать текущий момент - Flutter - лучший кроссплатформенный фреймворк, если вы
выбираете его для своих новых проектов. Возможно, в будущем его сместит с пьедестала kotlin
multiplatform, который на мой взгляд еще не достиг той кондиции, чтобы тягаться с ним.

## А что там кроме Flutter

Первое, что приходит в голову разработчику, который несколько лет работал с Xamarin Native, это
конечно же MAUI. Новый-старый флагманский UI фреймворк от Microsoft. Со старым подходом к построению
интерфейсов, перекочевавшим из Xamarin Forms. Чтобы как-то обосновать новое название, Microsoft
заявила о поддержке Desktop'a для Windows и MacOs и в итоге тратила все силы лишь бы подружить
старый мобильный фреймворк с жестами, поддержкой клавиатуры и прочими штуками, которые отличают
десктоп от мобилок. Уже маячит .NET 9, а команда maui из нововведений говорит лишь о каких то
улучшениях перформанса и прочих вещах, которые не особо интересны с точки зрения разработки.
Интуиция подсказывает, что MAUI закончится через год-два как Silverlight, WSA, UWP, VS for Mac
2022, <Вставьте свой пример технологии, которую похоронили микромягкие>.

И это очень обидная для меня история, учитывая мою любовь к платформе .NET. Надеюсь появятся
энтузиасты, на уровне разработчиков AvaloniaUI, способные сделать независимый фреймворк мечты для
мобильной разработки. Для меня он выглядит следующим образом. Это аналог Flutter'a с Hot Reload'ом,
декларативным UI и при этом с поддержкой F#, который на мой взгляд мог бы отлично вписаться в
декларативный подход. Возможно это дало бы второе рождение F#, по аналогии с тем, как это произошло
с dart. От Microsoft мы скорее всего не дождемся чего-то подобного, вслед за MAUI они придумают еще
один XAML фреймворк или насовсем забросят эту нишу.

Так же во время написания этой статьи я решил попробовать Kotlin Multiplatform. Опишу свои мысли,
касательно этой технологии, которые можно сделать спустя несколько дней после знакомства с ней:
Для меня жизнеспособной пока выглядит подход с раздельным UI. На андройде Jetpack Compose, на iOS -
SwiftUI. И только слои domain'a и data - общие для приложений на kotlin. Попробовав создать
приложение с shared UI - который для iOS еще в альфе, я понял, что в таком виде не смогу писать
приложение в том же комфортном режиме, как при разработке на Flutter.

Для меня пока еще выглядит дикой система сборки на основе kotlin.gradle.kts файлов. Я теряюсь в их
количестве, в том, что происходит внутри них. Процесс добавления каких-то библиотек тоже дикий после
Flutter'a и .NET - приходится с сайта библиотеки копировать строки с нужной версией вставлять их в
нужные места, разбросанные в разных .kts файлах. После pub и nuget менеджеров это для меня выглядит
какой-то лютой архаикой. Возможно мнение еще поменяется, но первое впечатление ровно такое.
Kotlin - one love, буквально с первых же примеров кода из туториалов по kmp. Причем некоторые
конструкции мне понравились уже через призму знакомства с dart. Если бы я сразу переключился с C# на
kotlin, возможно он бы не так мне зашёл.

## Выводы

Вывод для меня из всей этой истории перехода следующий - не нужно быть зашоренным в рамках одной
технологии, какой-бы крутой она вам не казалась. Сейчас я благодарен судьбе, что удалось вырваться
из разработки на Xamarin Native, который я превозносил, и к которому теперь не хочу возвращаться.

Следующий вывод - декларативный UI с нами надолго, поэтому, если вы не пробовали его, советую
попробовать. Особенно Flutter. Есть куча уроков на youtube - берете любой смотрите и повторяете, как
быстро делаются красивые интерфейсы, анимации и прочие вещи.
Расскажите, используете ли вы MAUI или Xamarin Native в проде. Был ли при этом у вас опыт работы с
декларативными фреймворками? Будет очень интересно почитать комментарии с вашими мнениями и
историями.

